# 목차
* [chapter 19. 비트 조작](#19장-비트-조작)
	+ [부울 연산자](#부울-연산자)
	+ [비트 연산자](#비트-연산자)
	+ [비트 조작 퀴즈](#비트-조작-퀴즈)
	+ [2의 보수](#2의-보수)
	+ [2의 보수와 NOT 연산자의 관계](#2의-보수와-not-연산자의-관계)
---
* [References](#references)

<br><br><br>

# 19장 비트 조작
원래 비트를 조작하는 것은 하드웨어와 관련이 깊다.<br>
1937년 클로드 섀넌(Claude Shannon)은 전기회로 스위치의 on/off를 이용한 스위칭 회로를 연구하면서 true, false의 2개 값으로 논리 연산을 설명하는 부울대수(Boolean Algebra)를 회로에 적용했고, 논리 게이트(Logic Gate)를 만들어냈다.<br>
이를 이용한 논리 회로(Logic Circuit)는 현대의 모든 디지털 컴퓨터의 기본 개념이자 근간을 이루고 있다.<br>
뿐만 아니라 현대에 이르러 비트 조작 기법은 하드웨어 뿐만 아니라 다양한 부분에 널리 활용된다.<br>
19장에서 살펴볼 비트 조작 또한 프로그래밍에서 활용하는 방법을 중심으로 다룬다. <br>
아울러 여기서는 수학적 표기보다는 컴퓨터과학에서 쓰이는 표기와 코드를 기준으로 살펴본다.

<br><br>

## 부울 연산자

<img src="https://user-images.githubusercontent.com/55045377/129554537-d14bb16c-4948-4b2f-904d-a7b493b11cf3.png" width=60% height=60%>

먼저, 가장 기본적인 부울 연산(Boolean Operation)부터 살펴보자.<br>
부울 연산은 그림 19-1과 같으며 코드로는 다음과 같이 표현할 수 있다.
```python
>>> True and False
False
>>> True or False
True
>>> not True
False
```
AND, OR, NOT은 기본 부울 연산자로, 연산들을 서로 결합하거나 조합해 다른 보조 연산을 만들어 낼 수 있다.<br>
대표적으로 XOR이 보조 연산에 해당하며, **기본 연산들의 조합으로 다음과 같이 XOR을 구성할 수 있다.**
```python
>>> x = y = True
>>> (x and not y) or (not x and y)
False
```
그러나 XOR은 단순한 보조 연산을 뛰어 넘어 디지털 논리 게이트에서 매우 중요한 위치를 차지한다.<br>
이후에 풀어볼 72번 문제에서 전가산기(Full Adder)를 구현해 보면서 XOR의 중요성을 다시 한번 실감하게 될 것이다.

<br><br>

## 비트 연산자
이번에는 비트 연산자(Bitwise Operator)를 살펴보자.
```python
>>> True & False
False
>>> True | False
True
>>> True ^ True
False
>>> ~ True
-2
```
부울 연산자와 마찬가지로 비트 연산자도 동일하게 잘 동작한다.<br>
그런데 비트 연산자 NOT(Bitwise NOT)인 **~(틸드)는 부울 변수에 적용하면 True는 1로 간주되어 -2가 된다.**<br>
비트 연산자 NOT은 2의 보수에서 1을 뺀 값과 같기 때문이다.<br>
따라서 십진수로 표현할 때는 NOT x = -x - 1이 된다. <br>
즉 NOT 1 = -1 - 1이 되어 -2가 된다.

* **2의 보수**<br>
	[-> 2의 보수 배우러 ㄱㄱ](https://github.com/jadeneu/TIL/blob/main/Math/%EB%B9%84%ED%8A%B8%20%EC%97%B0%EC%82%B0/2%EC%9D%98%20%EB%B3%B4%EC%88%98%EB%9E%80%3F.md)

<br><br>

## 비트 조작 퀴즈
* **참고**<br><br>
	```python
	>>> bin(13)    # 10진수 13을 2진수로 변환
	'0b1101'
	>>> 0b1101     # 2진수 1101을 10진수로 변환
	13
	```

이제 산술 연산(Arithmetic Operation)을 비롯한 몇 가지 비트 연산을 다음과 같이 살펴보자.
```python
>>> bin(0b0110 + 0b0010)   # 1
'0b1000'
>>> bin(0b0011 * 0b0101)   # 2
'0b1111'
>>> bin(0b1101 >> 2)       # 3
'0b11'
>>> bin(0b1101 << 2)       # 4
'0b110100'
>>> bin(0b0101 ^ ~0b1100)  # 5
'-0b1010'
```

* **# 1**<br>
	```python
	>>> bin(0b0110 + 0b0010)
	'0b1000'
	```
  ```
    11
    0110
  + 0010
  --------
    1000
  ```
  
* **# 2**<br>
	```python
	>>> bin(0b0011 * 0b0101)
	'0b1111'
	```
  ```
      0011
    * 0101
   ---------
      0011
     0000
    0011 
   0000  
   ---------
      1111
  ```
  
* **# 3**<br>
	[-> 시프트 연산](https://github.com/jadeneu/TIL/blob/main/Math/%EB%B9%84%ED%8A%B8%20%EC%97%B0%EC%82%B0/%EC%8B%9C%ED%94%84%ED%8A%B8%20%EC%97%B0%EC%82%B0.md)
	
	```python
	>>> bin(0b1101 >> 2)
	'0b11'
	```
  ```
  1101
    ↓    # (맨 오른쪽 비트 2개를 지우고 왼쪽에 지운 만큼 비트 0을 채운다)
  0011
  ```
	
* **# 4**<br>
	```python
	>>> bin(0b1101 << 2)
	'0b110100'
	```
	```
	00001101
	   ↓
	00110100
	```
	8비트로 계산한 이유는 4비트로 계산을 하게 되면 계산에 영향이 가기 때문이다.<br>
	
	* **위 예시를 4비트로 계산한 예**
		```
		1101
		 ↓
		0100
		```
		시프트 연산 결과가 달라진다.
		
	→ 따라서 비트 연산을 할 때는 비트를 확장해서 해석하고 연산하자.
	
* **# 5**<br>
	[-> NOT 연산](https://github.com/jadeneu/TIL/blob/main/Math/%EB%B9%84%ED%8A%B8%20%EC%97%B0%EC%82%B0/NOT%20%EC%97%B0%EC%82%B0%EC%9E%90.md)
	```python
	>>> bin(0b0101 ^ ~0b1100)
	'-0b1010'
	```
	```python
	# ~1100
	(8비트)00001100 -> (반전)11110011 -> (1의 보수)ㅁ0001100 -> (2의 보수)ㅁ0001101
	결과값: -13
	
	# -13의 2의 보수
	00001101 -> (1의 보수)11110010 -> (2의 보수)11110011
	
	# 00000101 ^ 11110011
	11110110
	
	# 11110110의 2의 보수
	ㅁ0001001 -> ㅁ0001010 -> -10
	```

<br><br>

## 2의 보수<br>
[-> 2의 보수 배우러 ㄱㄱ](https://github.com/jadeneu/TIL/blob/main/Math/%EB%B9%84%ED%8A%B8%20%EC%97%B0%EC%82%B0/2%EC%9D%98%20%EB%B3%B4%EC%88%98%EB%9E%80%3F.md)

<br><br>

### 2의 보수와 NOT 연산자의 관계
* 비트 연산자 NOT은 2의 보수에서 1을 뺀 것이다.
* 2의 보수 연산은 비트 연산자 NOT(0을 1로, 1을 0으로)에서 1을 더한 것이다.

예를 들어보면,

* 0b01011의 2의 보수 연산은 10100 + 1 = 10101이 된다. 
* 0b10101의 비트 연산자 NOT은 01011 - 1 = 01010(10)이 된다.

<br><br>























---
# References
* https://ndb796.tistory.com/4
* https://kbj96.tistory.com/28

<br><br><br>


